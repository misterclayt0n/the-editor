# Dispatch System Plan for the-editor

## Goals
- Implement dispatch-graph core aligned with docs/REWRITE.md: named dispatch points, no pipeline/next semantics, handlers can call any dispatch point.
- Provide zero-cost static handlers with an optional dynamic registry layer (opt-in) generated by macro.
- Support pre/on/post stages per dispatch point.
- Generate typed dispatch structs and builder-style overrides via `dispatch::define!` macro.
- Keep core editor free of keymap/mode logic; keymaps are just dispatch configs.
- Replace any implicit `ControlFlow` semantics with explicit handler-controlled flow (handlers call other points directly).

## Key Types / APIs (library-level, generic)
- `dispatch::define! { Name { point: InputType, ... } }`
  - Expands into `NameDispatch<...>` generic over handler types, with fields per point.
  - Generates `impl NameDispatch<Default...>` with `new()` and builder methods.
- Handler trait/alias:
  - `type Handler<Ctx, Input> = fn(&mut Ctx, Input);` plus `impl<F> Handler for F where F: Fn(&mut Ctx, Input)`.
  - Keep return `()` to avoid implicit `ControlFlow`; handlers manage control flow by calling dispatch points.
- Dispatch struct methods:
  - `fn pre_on_keypress(&mut self, ctx: &mut Ctx, input: Input)` etc.
  - Methods call the stored handler directly.
- Builder API:
  - `fn pre_on_keypress<H>(self, handler: H) -> NameDispatch<...>` replacing that generic parameter.
  - Default handlers are no-op unless otherwise specified in the macro.
- Dynamic registry (optional, opt-in):
  - `DispatchRegistry<Ctx>`: map `&'static str -> DynHandler<Ctx>`.
  - `DynHandler<Ctx>` likely `Box<dyn Fn(&mut Ctx, DynValue) -> DynValue>` or `Box<dyn Any>`-based wrapper with per-point type erasure.
  - `NameDispatch` gains `registry: Option<DispatchRegistry<Ctx>>` and helper methods:
    - `set_dyn("point", handler)` / `get_dyn("point")`
    - Typed handlers can consult registry explicitly (no implicit dispatch).

## Macro Responsibilities (define!)
- Parse:
  - Dispatch name, list of points, input types.
  - Optional configuration for default handlers (e.g., `= default_handler_fn`).
- Generate:
  - Dispatch struct with generic params and stored handlers.
  - `impl` with call methods per point (e.g., `fn on_keypress(&mut self, ctx: &mut Ctx, input: Input)`), no ControlFlow.
  - Builder methods for each point.
  - Default type aliases for standard handler types.
  - Registry integration behind a feature flag (e.g., `features = ["dynamic-registry"]`).
- Ensure the struct and builders are zero-cost when registry is disabled.

## Suggested Files to Edit
- `the-dispatch/src/lib.rs`
  - Replace placeholder `add` function.
  - Implement core dispatch types and macro exports.
- `the-dispatch/src/define.rs` (new)
  - Macro parsing and codegen for dispatch definitions.
- `the-dispatch/src/registry.rs` (new, optional module)
  - Dynamic registry types and utilities.
- `docs/REWRITE.md`
  - Update with refined macro/API signatures and the “no ControlFlow” behavior (explicit handler calls only).
- (Optional) `the-dispatch/Cargo.toml`
  - Add feature flag for dynamic registry if used.

## Implementation Steps
1. Replace `the-dispatch/src/lib.rs` with a minimal public surface: re-exports, `dispatch::define!` macro, and base handler traits/aliases.
2. Add macro implementation (`define.rs`) to generate:
   - dispatch struct, builder methods, call methods, default types.
3. Implement `registry.rs` and feature gate integration in macro output.
4. Update docs in `docs/REWRITE.md` to reflect exact API signatures, optional registry, and explicit handler-driven flow.

## Verification
- `cargo test -p the-dispatch` to ensure the crate compiles.
- Add a small doc test or unit test in `the-dispatch/src/lib.rs` or `tests/` to validate:
  - builder replacement works,
  - handlers can call other dispatch points,
  - dynamic registry is optional (feature flag build).