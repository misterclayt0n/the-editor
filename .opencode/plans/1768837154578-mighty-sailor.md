# Dispatch System UX Improvements Plan

## Priorities (based on user feedback)

1. **Zero-cost abstractions are critical** - Keep static dispatch, no `Box<dyn Fn>`
2. **Return type support** - Allow `point: Input -> Output` syntax
3. **Type inference is the top ergonomic priority** - Reduce underscore counting

---

## Current Pain Point

```rust
// Must count underscores for each dispatch point
let dispatch = EditorDispatch::<MyCtx, _, _, _, _, _, _, _, _>::new();

// Must annotate closure types
.with_on_keypress(|ctx: &mut MyCtx, key: Key| { ... })
```

---

## Proposed Changes

### 1. Restructure Generics: Single Handler Tuple (High Priority)

**Current generated struct:**
```rust
struct EditorDispatch<Ctx, OnKeypressHandler, OnActionHandler, RenderHandler, ...> {
    on_keypress: OnKeypressHandler,
    on_action: OnActionHandler,
    render: RenderHandler,
    // ... N fields = N generic parameters
}
```

**New approach - single tuple parameter:**
```rust
struct EditorDispatch<Ctx, Handlers = (
    fn(&mut Ctx, Key),      // on_keypress default
    fn(&mut Ctx, Action),   // on_action default
    fn(&mut Ctx, ()),       // render default
)> {
    handlers: Handlers,
    _ctx: PhantomData<Ctx>,
}
```

**Usage becomes:**
```rust
// Simple: just specify context
let dispatch = EditorDispatch::<MyCtx>::new();

// Or with full inference
let dispatch: EditorDispatch<MyCtx> = EditorDispatch::new();
```

**Implementation strategy:**
- Use a tuple to hold all handlers
- Default type parameter provides the default handler types
- Builder methods return new types with updated tuple positions
- Access handlers via tuple indexing internally

### 2. Add Return Type Syntax (High Priority)

**New syntax:**
```rust
define! {
    Editor {
        on_keypress: Key -> bool,           // Returns bool
        validate: Input -> Result<(), E>,   // Returns Result
        on_action: Action,                  // Returns () (default)
    }
}
```

**Generated code changes:**
```rust
// Handler trait becomes generic over return
pub trait HandlerFn<Ctx, Input, Output = ()> {
    fn call(&self, ctx: &mut Ctx, input: Input) -> Output;
}

// Dispatch method returns the output
pub fn on_keypress(&self, ctx: &mut Ctx, input: Key) -> bool {
    self.handlers.0.call(ctx, input)
}
```

**Macro parsing:**
- Parse `$point : $input` (returns `()`)
- Parse `$point : $input -> $output` (returns `$output`)

### 3. Context-Inference Helper Method (High Priority)

Add a simple associated function:

```rust
impl<Ctx> EditorDispatch<Ctx> {
    /// Create a new dispatch with default no-op handlers for the given context type.
    pub fn new() -> Self 
    where
        Self: Default,
    {
        Self::default()
    }
}
```

Or a more explicit helper:

```rust
impl EditorDispatch<()> {
    /// Create a dispatch for a specific context type.
    pub fn for_context<Ctx>() -> EditorDispatch<Ctx> {
        EditorDispatch::default()
    }
}

// Usage
let dispatch = EditorDispatch::for_context::<MyCtx>();
```

### 4. Improve Closure Type Inference (Medium Priority)

The builder methods should constrain types enough for inference:

```rust
impl<Ctx, H1, H2, H3> EditorDispatch<Ctx, (H1, H2, H3)> {
    pub fn with_on_keypress<NewH>(self, handler: NewH) -> EditorDispatch<Ctx, (NewH, H2, H3)>
    where
        NewH: Fn(&mut Ctx, Key) -> bool,  // Explicit bounds help inference
    {
        // ...
    }
}
```

With proper bounds, closures should infer types:
```rust
// Should work without annotations
.with_on_keypress(|ctx, key| {
    // ctx: &mut Ctx inferred from Fn bound
    // key: Key inferred from Fn bound
    true  // return type inferred
})
```

### 5. Handler Composition (Medium Priority)

Add `also_*` methods for chaining:

```rust
.with_on_keypress(|ctx, key| { log(key); true })
.also_on_keypress(|ctx, key| { handle(ctx, key) })
```

Implementation wraps handlers:
```rust
pub fn also_on_keypress<NewH>(self, handler: NewH) -> EditorDispatch<Ctx, (impl Fn(...), H2, H3)>
where
    NewH: Fn(&mut Ctx, Key) -> bool,
{
    let prev = self.handlers.0;
    let combined = move |ctx: &mut Ctx, key: Key| -> bool {
        prev.call(ctx, key);  // Run previous
        handler(ctx, key)     // Run new, return its result
    };
    // ...
}
```

### 6. Better Default Implementation (Low Priority)

Generate `Default` impl:
```rust
impl<Ctx> Default for EditorDispatch<Ctx> {
    fn default() -> Self {
        Self {
            handlers: (
                |_, _| Default::default(),  // on_keypress: returns default bool (false)
                |_, _| {},                   // on_action: returns ()
                // ...
            ),
            _ctx: PhantomData,
        }
    }
}
```

---

## Files to Modify

### `the-dispatch/lib.rs`
- Update `HandlerFn` trait to support return types: `HandlerFn<Ctx, Input, Output = ()>`
- Add blanket impl for `Fn(&mut Ctx, Input) -> Output`
- Export new helper types

### `the-dispatch/define.rs`
Major rewrite:

1. **Parse return types**: Handle `$point : $input` and `$point : $input -> $output`
2. **Generate tuple-based struct**: Single `Handlers` type parameter with default
3. **Generate `Default` impl**: For the default handler tuple
4. **Generate builder methods**: With proper type bounds for inference
5. **Generate `also_*` methods**: For handler composition
6. **Generate `for_context()` helper**: Context-inference method

### `the-dispatch/registry.rs`
- Add `Default` impl for `DispatchRegistry`
- Consider typed helper methods (lower priority)

### `the-dispatch/tests/`
- Update all tests for new API
- Add tests for return types
- Add tests for handler composition
- Test type inference works without annotations

---

## Migration Path

The API change is breaking. Options:

1. **Clean break**: New API replaces old
2. **Deprecation period**: Keep old API with `#[deprecated]`, add new alongside
3. **Version bump**: Release as 0.2.0 with new API

**Recommendation**: Clean break - this is an internal crate, not public yet.

---

## Example: Before and After

### Before
```rust
define! {
    Editor {
        on_keypress: Key,
        on_action: Action,
    }
}

let dispatch = EditorDispatch::<MyCtx, _, _>::new()
    .with_on_keypress(|ctx: &mut MyCtx, key: Key| {
        ctx.handle_key(key);
    })
    .with_on_action(|ctx: &mut MyCtx, action: Action| {
        ctx.execute(action);
    });
```

### After
```rust
define! {
    Editor {
        on_keypress: Key -> bool,  // Returns whether handled
        on_action: Action,
    }
}

let dispatch = EditorDispatch::<MyCtx>::new()
    .with_on_keypress(|ctx, key| {
        ctx.handle_key(key);
        true
    })
    .with_on_action(|ctx, action| {
        ctx.execute(action);
    });
```

**Improvements:**
- `<MyCtx>` instead of `<MyCtx, _, _>`
- No closure type annotations needed
- Return types supported

---

## Verification

1. `cargo build -p the-dispatch` - compiles
2. `cargo build -p the-dispatch --features dynamic-registry` - compiles with feature
3. `cargo test -p the-dispatch` - all tests pass
4. `cargo test -p the-dispatch --features dynamic-registry` - feature tests pass
5. Doc tests demonstrate the improved ergonomics
6. Verify closure type inference works in tests (no explicit annotations)
7. Verify return types work correctly

---

## Complexity Assessment

| Change | Complexity | Impact |
|--------|-----------|--------|
| Tuple-based generics | High | Eliminates underscore counting |
| Return type syntax | Medium | Enables richer handler contracts |
| Context helper | Low | Minor convenience |
| Better inference | Medium | Depends on tuple change |
| Handler composition | Medium | Nice-to-have |
| Default impl | Low | Minor convenience |

**Total estimated effort**: Significant macro rewrite, ~2-3 hours

---

## Design Decisions (Resolved)

1. **Nested tuples for >12 dispatch points**: Use `((H1,H2,...,H12), (H13,H14,...))` pattern to support unlimited dispatch points while maintaining tuple ergonomics.

2. **Return type defaults**: Missing return type defaults to `()`.

3. **Composition semantics**: Last handler wins - `also_*` returns the value from the most recently added handler.

---

## Implementation Order

### Step 1: Update `HandlerFn` trait (lib.rs)

```rust
/// Trait for callable handlers with return values.
pub trait HandlerFn<Ctx, Input, Output = ()> {
    fn call(&self, ctx: &mut Ctx, input: Input) -> Output;
}

impl<Ctx, Input, Output, F> HandlerFn<Ctx, Input, Output> for F
where
    F: Fn(&mut Ctx, Input) -> Output,
{
    fn call(&self, ctx: &mut Ctx, input: Input) -> Output {
        (self)(ctx, input)
    }
}
```

### Step 2: Update macro syntax parsing (define.rs)

Support both:
- `point: Input` (returns `()`)
- `point: Input -> Output` (returns `Output`)

```rust
// Internal representation after parsing
// Each point becomes: (name, input_type, output_type)
// where output_type defaults to () if not specified
```

### Step 3: Generate struct with nested tuples (define.rs)

For a dispatch with 3 points:
```rust
pub struct EditorDispatch<Ctx, Handlers = (
    fn(&mut Ctx, Key) -> bool,     // on_keypress
    fn(&mut Ctx, Action) -> (),    // on_action  
    fn(&mut Ctx, ()) -> (),        // render
)> {
    handlers: Handlers,
    _ctx: PhantomData<fn() -> Ctx>,  // Use fn() -> Ctx to avoid variance issues
    #[cfg(feature = "dynamic-registry")]
    registry: DispatchRegistry<Ctx>,
}
```

For >12 points, nest tuples:
```rust
// 15 points becomes:
Handlers = ((H1,H2,H3,H4,H5,H6,H7,H8,H9,H10,H11,H12), (H13,H14,H15))
```

### Step 4: Generate `new()` with inference helper

```rust
impl<Ctx> EditorDispatch<Ctx> {
    pub fn new() -> Self {
        Self {
            handlers: (
                (|_, _| false) as fn(&mut Ctx, Key) -> bool,
                (|_, _| ()) as fn(&mut Ctx, Action) -> (),
                (|_, _| ()) as fn(&mut Ctx, ()) -> (),
            ),
            _ctx: PhantomData,
            #[cfg(feature = "dynamic-registry")]
            registry: DispatchRegistry::new(),
        }
    }
}
```

### Step 5: Generate dispatch methods

```rust
impl<Ctx, H1, H2, H3> EditorDispatch<Ctx, (H1, H2, H3)>
where
    H1: HandlerFn<Ctx, Key, bool>,
    H2: HandlerFn<Ctx, Action, ()>,
    H3: HandlerFn<Ctx, (), ()>,
{
    pub fn on_keypress(&self, ctx: &mut Ctx, input: Key) -> bool {
        self.handlers.0.call(ctx, input)
    }
    
    pub fn on_action(&self, ctx: &mut Ctx, input: Action) {
        self.handlers.1.call(ctx, input)
    }
    
    pub fn render(&self, ctx: &mut Ctx) {
        self.handlers.2.call(ctx, ())
    }
}
```

### Step 6: Generate builder methods with proper bounds

```rust
impl<Ctx, H1, H2, H3> EditorDispatch<Ctx, (H1, H2, H3)> {
    pub fn with_on_keypress<NewH>(self, handler: NewH) -> EditorDispatch<Ctx, (NewH, H2, H3)>
    where
        NewH: Fn(&mut Ctx, Key) -> bool,  // Explicit bound helps inference
    {
        EditorDispatch {
            handlers: (handler, self.handlers.1, self.handlers.2),
            _ctx: PhantomData,
            #[cfg(feature = "dynamic-registry")]
            registry: self.registry,
        }
    }
}
```

### Step 7: Generate `also_*` methods

```rust
impl<Ctx, H1, H2, H3> EditorDispatch<Ctx, (H1, H2, H3)>
where
    H1: HandlerFn<Ctx, Key, bool>,
{
    pub fn also_on_keypress<NewH>(self, handler: NewH) 
        -> EditorDispatch<Ctx, (impl HandlerFn<Ctx, Key, bool>, H2, H3)>
    where
        NewH: Fn(&mut Ctx, Key) -> bool,
    {
        let prev = self.handlers.0;
        let combined = move |ctx: &mut Ctx, input: Key| -> bool {
            let _ = prev.call(ctx, input);  // Call previous, ignore result
            handler(ctx, input)              // Return new handler's result
        };
        EditorDispatch {
            handlers: (combined, self.handlers.1, self.handlers.2),
            _ctx: PhantomData,
            #[cfg(feature = "dynamic-registry")]
            registry: self.registry,
        }
    }
}
```

### Step 8: Update tests and documentation
